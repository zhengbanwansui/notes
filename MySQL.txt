

索引的优缺点？
加快搜索速度，联表速度，分组速度，排序速度，但是索引需要维护所以会减慢修改速度

innodb引擎的主键默认是聚簇索引（B+树）的Key，数据存储在B+树的叶子节点，叶子节点连成一个链表
数据在B+树的节点里是按key的顺序存储的，自增主键可以让新数据直接插入到链表末尾，不需要重新定位新数据的位置或移动旧数据
主键效率高的情况：
使用自增ID，没有可以作为索引的唯一key，使用隐藏的自增id

事务的特性ACID
【原子性】全成功 / 全失败
【一致性】从一个有效状态（符合数据库约束条件的状态）到另一个有效状态
【隔离性】一个事务无法读取到其他事务的中间数据
【持久性】事务执行成功后会持久化到硬盘上

并发事务引起的问题？
【脏读】读取了已修改但未提交的数据
【幻读】读取了新增的数据
【不可重复读】读取了数据再次读取数据改变了
【丢失修改】隔离级别解决不了的问题：第一类回滚丢失、第二类更新丢失：指A事务查询和修改过程中查询到的结果被B事务修改，A事务覆盖了B事务
因此建议查询时使用【for update结尾】悲观锁，或【version】乐观锁

MySQL隔离级别？
【读取未提交】   脏读、幻读、不可重复读
【读取已提交】（解决脏读）幻读、不可重复读
【可重复读   】（行锁解决不可重复读）幻读
【可串行化   】（读写都加锁解决幻读）

MySQL隔离级别是如何实现的？
【读取未提交】无限制
【读取已提交】mvcc读取最新值
【可重复读   】mvcc读取旧值
【可串行化   】读写都加锁

MVCC原理？
解决了读写互相不阻塞，降低死锁概率，解决一致性读问题
