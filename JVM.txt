-server服务器模式
-Xmx3000m最大堆内存
-Xms3000m最小堆内存
-Xss512k每个线程内存
-Xmn1125m年轻代一般设置为3/8（Xmx = Xms且设置此项则不需要设置-XX:NewRatio=4  年轻一份，老年四份）
-XX:SurvivorRatio=8（年轻代中伊甸占8份，两个Servivor各1份）


JVM内存结构
Heap堆 non-Heap非堆也就是元空间（存储常量，静态变量，JIT代码，加载的类信息）
程序计数器（不会OOM） 虚拟机栈（调用方法压栈，返回或抛异常弹栈） 本地方法栈

对于一个大对象，我们会首先在Eden 尝试创建，如果创建不了，就会触发Minor GC
随后继续尝试在Eden区存放，发现仍然放不下
尝试直接进入老年代，老年代也放不下
触发 Major GC 清理老年代的空间
放的下 成功
放不下 OOM

Minor GC后旧对象进入Servivor区，Servivor区对象增长年龄

对象死亡判断：
引用链从GC root开始向下寻找，找不到的死亡
给对象一个引用计数器，引用归零死亡（强引用，软引用内存不足时回收，弱引用随时回收）

吞吐量：
运行代码时间/（运行代码时间+垃圾收集时间）

【GC算法：理论】
标记清除（标记死亡对象定点清除，内存碎片多）
复制（分两个区，A区存活对象复制到B区然后清空A区，空间浪费50%）
标记整理（标记死亡对象，存活对象集中移动到一端然后清空边界外的内存区域，空间利用率高碎片少）
分代（分为新生代和老年代根据合适的区域选择合适的算法，新生代采用复制，老年代采用标记整理标记清除）

【GC收集器：实现】
--------------------------------------------------------------------------------
-XX:+UseSerialGC
Serial串行收集器，单线程稳定效率高，新串行（复制），老串行（标记整理）
--------------------------------------------------------------------------------
-XX:+UseParNewGC
-XX:ParallelGCThreads 限制线程数量
ParNew收集器是Serial收集器的多线程版本，新并发（复制），老串行（标记整理）
--------------------------------------------------------------------------------
-XX:+UseParallelGC
Parallel收集器类似ParNew收集器，关注吞吐量，可以通过参数打开自定义调节，可以控制GC时间，新并发（复制），老串行（标记整理）
--------------------------------------------------------------------------------
-XX:+UseConcMarkSweepGC
-XX:+ UseCMSCompactAtFullCollection 进行Full GC后，进行碎片整理，整理过程是独占的，会引起停顿时间变长
-XX:+CMSFullGCsBeforeCompaction  设置进行几次Full GC后，进行一次碎片整理
-XX:ParallelCMSThreads  设定CMS的线程数量（一般情况约等于可用CPU数量）

CMS收集器倾向于最少的回收停顿时间，低停顿，有碎片，并发清除时吞吐量降低
它是老年代回收器（新生代使用parNew），新并发（复制），老串行+并发（标记清除）
初始标记（串CMS initial mark）
并发标记（并CMS concurrent mark）
重新标记（串CMS remark）
并发清除（并CMS concurrent sweep）
--------------------------------------------------------------------------------
-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC        #开启
-XX:MaxGCPauseMillis =50                  #暂停时间目标
-XX:GCPauseIntervalMillis =200          #暂停间隔目标

G1收集器是为了替换CMS收集器而出现的新收集器，标记整理，可以设置一定时间内GC时间不超过多少毫秒
新生代和老年代被看作多个内存块，新生代类似ParNew，并发收集，老年代类似CMS有短暂停顿+并发
初始标记+minorGC（停顿）
minorGC之前先处理Servivor区晋升
并发标记、计算内存区块活性、全死亡则直接回收
重新标记、并发收集期间的新死亡对象、采用了比CMS更快的初始快照算法（短暂停顿）
并发清除、将回收对象复制到新区域，清空回收区域（属于标记整理范畴）
--------------------------------------------------------------------------------
技术选型一般就是【ParNew+CMS】【G1+G1】

【实测性能】
五分钟性能测试 100线程1秒无限循环
默认parellel收集器80次2000ms
G1收集器40次1200ms5

【优化建议】
minor gc建议不高于4s/次，每次停顿时间控制在20ms以内。
major gc越少越好，不过基本上不可能杜绝major gc。建议一天次数控制在个位数。